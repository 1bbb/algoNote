# LeetCode 1001 - 1050

### 1003. Check If Word Is Valid After Substitutions

We are given that the string `"abc"` is valid. From any valid string `V`, we may split `V` into two pieces `X` and `Y` such that `X + Y` (`X` concatenated with `Y`) is equal to `V`.  (`X`or `Y` may be empty.)  Then, `X + "abc" + Y` is also valid.

If for example `S = "abc"`, then examples of valid strings are: `"abc", "aabcbc", "abcabc", "abcabcababcc"`.  Examples of **invalid** strings are: `"abccba"`, `"ab"`, `"cababc"`, `"bac"`. Return `true` if and only if the given string `S` is valid.

Example:

```
Input: "abcabcababcc"
Output: true
```

Solution: stack（实际上需要用vector，方便获得back()-1位置的值）

```cpp
bool isValid(string S) {
    vector<char> stack;
    for (char c : S) {
        if (c == 'c') {
            int n = stack.size();
            if (n < 2 || stack[n - 1] != 'b' || stack[n - 2] != 'a') return false;
            stack.pop_back(), stack.pop_back();
        } else {
            stack.push_back(c);
        }
    }
    return stack.empty();
}
```

### 1004. Max Consecutive Ones III

Given an array `A` of 0s and 1s, we may change up to `K` values from 0 to 1. Return the length of the longest (contiguous) subarray that contains only 1s. 

Example:

```
Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
Output: 6 ([1,1,1,0,0,1,1,1,1,1,1])
```

Solution: 滑动窗口

```cpp
int longestOnes(vector<int>& A, int K) {
    int l = 0, r = 0, flips = 0, res = 0;
    while (r < A.size()) {
        if (A[r] == 0) {
            if (flips < K) {
                ++flips;
            } else {
                if (A[l] == 1)
                    while (A[l++] == 1) continue;
                else ++l;
            }
        }
        res = max(res, ++r - l);
    }
    return res;
}
```

### 1005. Maximize Sum Of Array After K Negations

Given an array `A` of integers, we **must** modify the array in the following way: we choose an `i` and replace `A[i]` with `-A[i]`, and we repeat this process `K` times in total.  (We may choose the same index `i` multiple times.) Return the largest possible sum of the array after modifying it in this way.

Example:

```
Input: A = [3,-1,0,2], K = 3
Output: 6
```

Solution: 分正负数操作即可

```cpp
int largestSumAfterKNegations(vector<int>& A, int K) {
    int n = A.size();
    vector<int> pos, neg;
    for (auto & i: A) {
        if (i < 0) neg.push_back(i);
        else pos.push_back(i);
    }
    int sum = accumulate(pos.begin(), pos.end(), 0);
    if (K <= neg.size()) {
        sort(neg.begin(), neg.end());
        sum -= accumulate(neg.begin(), neg.begin() + K, 0);
        sum += accumulate(neg.begin() + K, neg.end(), 0);
    } else {
        for (auto & i: neg) {
            pos.push_back(-i);
        }
        sort(pos.begin(), pos.end());
        if ((K - neg.size()) % 2) {
            sum -= 2 * pos[0];
        }
    }
    return sum;
}
```

### 1006. Clumsy Factorial

Normally, the factorial of a positive integer `n` is the product of all positive integers less than or equal to `n`.  For example, `factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1`.

We instead make a *clumsy factorial:* using the integers in decreasing order, we swap out the multiply operations for a fixed rotation of operations: multiply (*), divide (/), add (+) and subtract (-) in this order.

For example, `clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1`.  However, these operations are still applied using the usual order of operations of arithmetic: we do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.

Additionally, the division that we use is *floor division* such that `10 * 9 / 8` equals `11`.  This guarantees the result is an integer.

`Implement the clumsy` function as defined above: given an integer `N`, it returns the clumsy factorial of `N`

Example:

```
Input: 10
Output: 12 (12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1)
```

Solution: 数学题

```cpp
int clumsy(int N) {
    if (N <= 2) return N;
    if (N <= 4) return N + 3;
    if ((N - 4) % 4 == 0) return N + 1;
    else if ((N - 4) % 4 <= 2) return N + 2;
    return N - 1;
}
```

### 1007. Minimum Domino Rotations For Equal Row

In a row of dominoes, `A[i]` and `B[i]` represent the top and bottom halves of the `i`-th domino.  (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.) We may rotate the `i`-th domino, so that `A[i]` and `B[i]` swap values.

Return the minimum number of rotations so that all the values in `A` are the same, or all the values in `B` are the same. If it cannot be done, return `-1`.

Example:

```
Input: A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]
Output: 2 (If we rotate the second and fourth dominoes, we can make every value in A equal to 2.)
```

Solution: 遍历一遍找满足条件的数字，再遍历一遍求最小交换次数，注意各种细节，一定要背

```cpp
int minDominoRotations(vector<int>& A, vector<int>& B) {
    // find mode
    int mode_a = A[0], mode_b = B[0];
    int n = A.size();
    for (int i = 1; i < n; ++i) {
        if (mode_a && mode_a != A[i] && mode_a != B[i]) mode_a = 0;
        if (mode_b && mode_b != A[i] && mode_b != B[i]) mode_b = 0;
    }
    if (!mode_a && !mode_b) return -1;

    // find move times
    int move_cnt = INT_MAX, mode = mode_a? mode_a: mode_b;
    int move_cnt_a = 0, move_cnt_b = 0;
    for (int i = 0; i < n; ++i) {
        if (mode != A[i]) ++move_cnt_a;
        if (mode != B[i]) ++move_cnt_b;
    }
    move_cnt = min(move_cnt, min(move_cnt_a, n-move_cnt_a));
    move_cnt = min(move_cnt, min(move_cnt_b, n-move_cnt_b));

    return move_cnt;
}
```

### 1008. Construct Binary Search Tree from Preorder Traversal

Return the root node of a binary **search** tree that matches the given `preorder` traversal.

Example:

```
Input: [8,5,1,7,10,12]
Output: [8,5,10,1,7,null,12]
    8
   / \
  5   10
 / \    \
1   7   12
```

Solution: 二分法，一定要背

```cpp
TreeNode* bstFromPreorder(vector<int>& preorder) {
    return helper(preorder, 0, preorder.size());
}

TreeNode* helper(vector<int>& preorder, int l, int r) {
    if (l == r) return NULL;
    TreeNode* root = new TreeNode(preorder[l]);
    if (l + 1 < r) {
        int pos = binary_search(preorder, l + 1, r, preorder[l]);
        root->left  = helper(preorder, l+1, pos);
        root->right = helper(preorder, pos, r);
    }
    return root;
}

int binary_search(vector<int>& preorder, int l, int r, int target) {
    while (l < r) {
        int m = (l + r) / 2;
        if (preorder[m] < target) l = m + 1;
        else r = m;
    }
    return l;
}
```

### 1009. Complement of Base 10 Integer

Every non-negative integer `N` has a binary representation.  For example, `5` can be represented as `"101"` in binary, `11` as `"1011"` in binary, and so on.  Note that except for `N = 0`, there are no leading zeroes in any binary representation. The *complement* of a binary representation is the number in binary you get when changing every `1` to a `0` and `0` to a `1`.  For example, the complement of `"101"` in binary is `"010"` in binary. For a given number `N` in base-10, return the complement of it's binary representation as a base-10 integer.

Example:

```
Input: 5
Output: 2 (5 is "101" in binary, with complement "010" in binary, which is 2 in base-10.)
```

Solution: 2^n - 1 - input

```cpp
int bitwiseComplement(int N) {
    int X = 1;
    while (N > X) X = X * 2 + 1;
    return X - N;
}
```

### 1010. Pairs of Songs With Total Durations Divisible by 60

In a list of songs, the `i`-th song has a duration of `time[i]`seconds. Return the number of pairs of songs for which their total duration in seconds is divisible by `60`.  Formally, we want the number of indices `i < j` with `(time[i] + time[j]) % 60 == 0`.

Example:

```
Input: [30, 20, 150, 100, 40]
Output: 3 ([0, 2], [1, 3], [1, 4])
```

Solution: 前缀和，和974相同，注意既可以先统计然后算`C(freq,  2)`，也可以在遍历时求和，即`1 + 2 + ... + freq = freq * (freq-1) / 2 = C(freq, 2)`

```cpp
int numPairsDivisibleBy60(vector<int>& time) {
    vector<int> freqmap(60, 0);
    int res = 0;
    for (const int & t: time) {
        int modt = t % 60;
        if (modt == 0) res += freqmap[0];
        else res += freqmap[60 - modt];
        ++freqmap[modt];
    }
    return res;
}
```

### 1011. Capacity To Ship Packages Within D Days

A conveyor belt has packages that must be shipped from one port to another within `D` days. The `i`-th package on the conveyor belt has a weight of `weights[i]`.  Each day, we load the ship with packages on the conveyor belt (in the order given by `weights`). We may not load more weight than the maximum weight capacity of the ship. Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within `D` days.

Example:

```
Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5
Output: 15 ([1, 2, 3, 4, 5], [6, 7], [8], [9], [10])
```

Solution: 二分法，`l = max(max_element(weights), sum(weights) / D) , r = sum(weights)`，一定要背

```cpp
int countDays(vector<int>& ws, int tot_cap, int cur_cap = 0, int res = 1) {
    for (int w : ws) {
        cur_cap += w;
        if (cur_cap > tot_cap) ++res, cur_cap = w;
    }
    return res;
}
int shipWithinDays(vector<int>& ws, int D) {
    int r = accumulate(begin(ws), end(ws), 0);
    int l = max(r / D, *max_element(begin(ws), end(ws)));
    while (l < r) {
        int m = (l + r) / 2;
        if (countDays(ws, m) <= D) r = m;
        else l = m + 1;
    }
    return l;
}
```

### 1013. Partition Array Into Three Parts With Equal Sum

Given an array `A` of integers, return `true` if and only if we can partition the array into three **non-empty** parts with equal sums.

Example:

```
Input: [0,2,1,-6,6,-7,9,1,2,0,1]
Output: true ([0,2,1],[-6,6,-7,9,1],[2,0,1])
```

Solution: 遍历一遍找是否有`sum / 3`和`sum * 2 /3`的位置

```cpp
bool canThreePartsEqualSum(vector<int>& A) {
    int total = accumulate(A.begin(), A.end(), 0);
    if (total % 3) return false;
    bool f1 = false;
    int csum = 0;
    for (int num: A) {
        csum += num;
        if (!f1 && csum == total/3) f1 = true;
        else if (f1 && csum == (2*total)/3) return true;
    }
    return false;
}
```

### 1014. Best Sightseeing Pair

Given an array `A` of positive integers, `A[i]` represents the value of the `i`-th sightseeing spot, and two sightseeing spots `i` and `j` have distance `j - i` between them. The *score* of a pair (`i < j`) of sightseeing spots is (`A[i] + A[j] + i - j)` : the sum of the values of the sightseeing spots, **minus** the distance between them. Return the maximum score of a pair of sightseeing spots.

Example:

```
Input: [8,1,5,2,6]
Output: 11 (i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11)
```

Solution: 先做前缀和，然后从后往前遍历找每个位置之后的最大值，然后再遍历一遍即可

```cpp
int maxScoreSightseeingPair(vector<int>& A) {
    int n = A.size();
    if (n == 2) return A[0] + A[1] - 1;
    vector<int> curmax(n, 0);
    // build curmax from i to n
    for (int i = 1; i < n; ++i) {
        curmax[i] = A[i] - i;
    }
    for (int i = n - 2 ; i >= 1; --i) {
        curmax[i] = max(curmax[i+1], curmax[i]);
    }
    // scan through
    int res = A[0] + curmax[1], cur = res;
    for (int i = 1; i < n - 1; ++i) {
        cur = A[i] + i + curmax[i+1];
        res = max(res, cur);
    }
    return res;
}
```

### 1017. Convert to Base -2

Given a number `N`, return a string consisting of `"0"`s and `"1"`s that represents its value in base `**-2**` (negative two). The returned string must have no leading zeroes, unless the string is `"0"`.

Example:

```
Input: 2
Output: "110" ((-2) ^ 2 + (-2) ^ 1 = 2)
```

Solution: 循环mod -2，取绝对值，一定要背

```cpp
string baseNeg2(int N) {
    string s = "";
    while (N) {
        int a = abs(N % (-2));
        s = (a == 0? '0' :'1') + s;
        N = (N - a) / (-2);
    }
    return s == ""? "0" : s;   
}
```

### 1018. Binary Prefix Divisible By 5

Given an array `A` of `0`s and `1`s, consider `N_i`: the i-th subarray from `A[0]` to `A[i]` interpreted as a binary number (from most-significant-bit to least-significant-bit.) Return a list of booleans `answer`, where `answer[i]` is `true` if and only if `N_i` is divisible by 5.

Example:

```
Input: [0,1,1,1,1,1]
Output: [true,false,false,false,true,false]
```

Solution: 遍历一遍即可，注意一个细节是在每次计算完当前位置时mod 5，防止超出最大范围，一定要背

```cpp
vector<bool> prefixesDivBy5(vector<int>& A) {
    vector<bool> result;
    int number = 0;
    for (int i = 0; i < A.size(); i++){
        number <<= 1;
        number += A[i];
        number %= 5;  // attention!
        result.push_back(number % 5 == 0);
    }
    return result;
}
```

### 1019. Next Greater Node In Linked List

We are given a linked list with `head` as the first node. Return an array of integers `answer`, where `answer[i] = next_larger(node_{i+1})`.

Example:

```
Input: 2->7->4->3->5
Output: [7,0,5,5,0]
```

Solution: stack

```cpp
vector<int> nextLargerNodes(ListNode* head) {
    vector<int> ans;
    if (!head) return ans;
    stack<pair<int, int>> s;  // {node_val, node_index} 
    int i = 0;
    while (head) {
        while (!s.empty() && head->val > s.top().first) {
            ans[s.top().second] = head->val;
            s.pop();
        }
        s.push({head->val, i++});
        ans.push_back(0);
        head = head->next;
    }
    return ans;
}
```

### 1020. Number of Enclaves

Given a 2D array `A`, each cell is 0 (representing sea) or 1 (representing land). A move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid. Return the number of land squares in the grid for which we **cannot** walk off the boundary of the grid in any number of moves.

Example:

```
Input: [
    [0,0,0,0],
    [1,0,1,0],
    [0,1,1,0],
    [0,0,0,0]
]
Output: 3
```

Solution: dfs

```cpp
int numEnclaves(vector<vector<int>>& A) {
    int m = A.size(), n = A[0].size();
    for (int i = 0; i < m; ++i) {
        dfs(A, i, 0, m, n);
        dfs(A, i, n-1, m, n);
    }
    for (int j = 0; j < n; ++j) {
        dfs(A, 0, j, m, n);
        dfs(A, m-1, j, m, n);
    }
    int res = 0;
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (A[i][j] == 1) {
                ++res;
            }
        }
    }
    return res;
}

void dfs(vector<vector<int>>& A, int i, int j, int m, int n) {
    if (i < 0 || i >= m || j < 0 || j >= n || A[i][j] == 0) return;
    A[i][j] = 0;
    dfs(A, i-1, j, m, n);
    dfs(A, i+1, j, m, n);
    dfs(A, i, j-1, m, n);
    dfs(A, i, j+1, m, n);
}
```

### 1021. Remove Outermost Parentheses

A valid parentheses string is either empty `("")`, `"(" + A + ")"`, or `A + B`, where `A` and `B` are valid parentheses strings, and `+` represents string concatenation.  For example, `""`, `"()"`, `"(())()"`, and `"(()(()))"` are all valid parentheses strings.

A valid parentheses string `S` is **primitive** if it is nonempty, and there does not exist a way to split it into `S = A+B`, with `A` and `B`nonempty valid parentheses strings.

Given a valid parentheses string `S`, consider its primitive decomposition: `S = P_1 + P_2 + ... + P_k`, where `P_i` are primitive valid parentheses strings. Return `S` after removing the outermost parentheses of every primitive string in the primitive decomposition of `S`.

Example:

```
Input: "(()())(())(()(()))"
Output: "()()()()(())" ("()()" + "()" + "()(())")
```

Solution: 遍历一遍即可

```cpp
string removeOuterParentheses(string S) {
    string ret = "";
    int left = 0;
    for (char c: S) {
        if (c == '(') {
            if (left != 0) ret += c;
            ++left;
        } else {
            --left;
            if (left != 0) ret += c;
        }
    }
    return ret;
}
```

### 1022. Sum of Root To Leaf Binary Numbers

Given a binary tree, each node has value `0` or `1`.  Each root-to-leaf path represents a binary number starting with the most significant bit. For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers.

Example:

```
Input: [1,0,1,0,1,0,1]
     1
   /   \
  0     1
 / \   / \
0   1 0   1
Output: 22 ((100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22)
```

Solution: dfs

```cpp
int sum;
void findSum(TreeNode* root, int val) {
    if (!root) return;
    val <<= 1;
    val += root->val;
    if (!root->left && !root->right) {
        sum += val;
        return;
    }
    findSum(root->left, val);
    findSum(root->right, val);
}
int sumRootToLeaf(TreeNode* root) {
    sum = 0;
    findSum(root, 0);
    return sum;
}
```

### 1023. Camelcase Matching

A query word matches a given `pattern` if we can insert **lowercase** letters to the pattern word so that it equals the `query`. (We may insert each character at any position, and may insert 0 characters.)

Given a list of `queries`, and a `pattern`, return an `answer` list of booleans, where `answer[i]` is true if and only if `queries[i]`matches the `pattern`.

Example:

```
Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer"], pattern = "FoBa"
Output: [true,false,true,false]
```

Solution: 找到所有的组成词，然后看剩余的字母是不是全部小写，可以用find，lambda和algorithm简化代码

```cpp
vector<bool> camelMatch(vector<string>& qs, string pattern) {
    vector<bool> res;
    for (auto i = 0; i < qs.size(); ++i) {
        for (auto p = -1, j = 0; j < pattern.size(); ++j) {
            p = qs[i].find(pattern[j], p + 1);
            if (p == string::npos) {
                res.push_back(false);
                break;
            }
            qs[i][p] = 'a';
        }
        if (res.size() <= i) {
            res.push_back(all_of(begin(qs[i]), end(qs[i]), [](char ch) { return islower(ch); }));
        }
    }
  return res;
}
```

### 1024. Video Stitching

You are given a series of video clips from a sporting event that lasted `0 <= T <= 100` seconds.  These video clips can be overlapping with each other and have varied lengths.

Each video clip `clips[i]` is an interval: it starts at time `clips[i][0]` and ends at time `clips[i][1]`.  We can cut these clips into segments freely: for example, a clip `[0, 7]` can be cut into segments `[0, 1] + [1, 3] + [3, 7]`.

Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event (`[0, T]`).  If the task is impossible, return `-1`.

Example:

```
Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
Output: 3 (We take the clips [0,2], [8,10], [1,9]; a total of 3 clips to form [0, 10])
```

Solution: 鉴于本题T范围较小，不需要sort，可以直接遍历一遍clips记录每个开始时间对应的最晚结束时间，然后按照时间T遍历一遍，一定要背

```cpp
int videoStitching(vector<vector<int>>& clips, int T) {
    vector<int> max_end(T + 1, -1);
    for (const auto& clip : clips) {
        if (clip[0] <= T) {
            max_end[clip[0]] = max(max_end[clip[0]], clip[1]);
        }
    }
    int ret = 1;
    int curr_end = max_end[0];
    int next_end = 0;
    for (int curr_start = 0; curr_start <= curr_end && curr_end < T; ++curr_start) {
        next_end = max(next_end, max_end[curr_start]);
        if (curr_start == curr_end) {
            curr_end = next_end;
            if (curr_start == curr_end) return -1;
            ++ret;
        }
    }
    return curr_end >= T ? ret : -1;
}
```

### 1025. Divisor Game

Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number `N` on the chalkboard.  On each player's turn, that player makes a *move* consisting of:

- Choosing any `x` with `0 < x < N` and `N % x == 0`.
- Replacing the number `N` on the chalkboard with `N - x`.

Also, if a player cannot make a move, they lose the game. Return `True` if and only if Alice wins the game, assuming both players play optimally.

Example:

```
Input: 2
Output: true
```

Solution: 奇偶数

```cpp
bool divisorGame(int N) {
    return N % 2 == 0;
}
```

### 1026. Maximum Difference Between Node and Ancestor

Given the `root` of a binary tree, find the maximum value `V` for which there exists **different** nodes `A` and `B` where `V = |A.val - B.val|` and `A` is an ancestor of `B`. (A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)

Example:

```
Input: [1,2,3,4]
    1
   / \
  2   3
 /
4
Output: 3 (|1 - 4|)
```

Solution: dfs

```cpp
int maxAncestorDiff(TreeNode* root) {
    int global_max = 0;
    dfs(root, global_max);
    return global_max;
}

pair<int,int> dfs(TreeNode * root, int& global_max){
    int local_min=root->val, local_max=root->val;
    if (root->left) {
        auto pt = dfs(root->left, global_max);
        local_min = min(local_min, pt.first);
        local_max = max(local_max, pt.second);
    }
    if (root->right) {
        auto pt = dfs(root->right, global_max);
        local_min = min(local_min, pt.first);
        local_max = max(local_max, pt.second);
    }
    global_max = max(root->val-local_min, max(local_max-root->val, global_max));
    return make_pair(local_min, local_max);
}
```

### 1027. Longest Arithmetic Sequence

Given an array `A` of integers, return the **length** of the longest arithmetic subsequence in `A`. Recall that a *subsequence* of `A` is a list `A[i_1], A[i_2], ..., A[i_k]` with `0 <= i_1 < i_2 < ... < i_k <= A.length - 1`, and that a sequence `B` is *arithmetic* if `B[i+1] - B[i]` are all the same value (for `0 <= i < B.length - 1`).

Example:

```
Input: [9,4,7,2,10]
Output: 3 ([4,7,10])
```

Solution: 用map<pair<截止位index，递增差>, 连续递增个数>做dp，这样每个位置可以有多个递增差，一定要背

```cpp
int longestArithSeqLength(vector<int>& A) {
    int n = A.size();
    if (n <= 2) return n; 
    map<pair<int,int>, int> dp;  // seq-end, common-diff
    int ans = INT_MIN;
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            int diff = A[i] - A[j];
            if (dp.find({j, diff}) == dp.end()) {
                dp[{j, diff}] = 1;  // base
            }
            dp[{i, diff}] = dp[{j, diff}] + 1;
            ans = max(ans, dp[{i, diff}]);
        }        
    }
    return ans;
}
```

### 1029. Two City Scheduling

There are `2N` people a company is planning to interview. The cost of flying the `i`-th person to city `A` is `costs[i][0]`, and the cost of flying the `i`-th person to city `B` is `costs[i][1]`. Return the minimum cost to fly every person to a city such that exactly `N` people arrive in each city.

Example:

```
Input: [[10,20],[30,200],[400,50],[30,20]]
Output: 110 (10 + 30 + 50 + 20)
```

Solution: 按照`diff = costs[i][0] - costs[i][1]`排序，选`diff`前N大的去B，其他去A

```cpp
int twoCitySchedCost(vector<vector<int>>& A) {
    int res = 0, n = A.size();
    sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b){
            return a[0]-a[1] < b[0]-b[1];
        });
    for (int i = 0; i < n/2; ++i) {
        res += A[i][0] + A[n-1-i][1];
    }
    return res;
}
```

### 1030. Matrix Cells in Distance Order

We are given a matrix with `R` rows and `C` columns, and a cell in that matrix with coordinates `(r0, c0)`. Return the coordinates of all cells in the matrix, sorted by their distance from `(r0, c0)` from smallest distance to largest distance.  Here, the distance between two cells `(r1, c1)` and `(r2, c2)` is the Manhattan distance, `|r1 - r2| + |c1 - c2|`.  You may return the answer in any order that satisfies this condition.

Example:

```
Input: R = 2, C = 3, r0 = 1, c0 = 2
Output: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]] (The distances from (r0, c0) to other cells are [0,1,1,2,2,3])
```

Solution: 排序+lambda

```cpp
vector<vector<int>> allCellsDistOrder(int R, int C, int r0, int c0) {
    vector<vector<int>> cells;
    for (int i = 0; i < R; ++i) for (int j = 0; j < C; ++j) cells.push_back(vector<int>{i, j});
    sort(cells.begin(), cells.end(), [=](const vector<int> & va, const vector<int> & vb) {
        return abs(va[0] - r0)  + abs(va[1] - c0) < abs(vb[0] - r0) + abs(vb[1] - c0);
    });
    return cells;
}
```

### 1031. Maximum Sum of Two Non-Overlapping Subarrays

Given an array `A` of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths `L` and `M`. 

Example:

```
Input: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2
Output: 20 (L:[9], M:[6,5])
```

Solution: 先做前缀和，然后遍历一遍，遍历时更新L和M的当前最大值，非常巧妙，一定要背

```cpp
int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {
    vector<int> sums;
    sums.push_back(A[0]);
    for (int i = 1; i < A.size(); ++i) sums.push_back(sums[i-1] + A[i]);   
    int Lmax = sums[L-1], Mmax = sums[M-1];
    int maxSum = sums[M+L-1];
    for (int i = L + M; i < A.size(); ++i)
        Lmax = max(Lmax, sums[i-M] - sums[i-M-L]);
        Mmax = max(Mmax, sums[i-L] - sums[i-M-L]);
        maxSum = max(maxSum, max(Mmax + sums[i] - sums[i-L], Lmax + sums[i] - sums[i-M]));
    }
    return maxSum;
}
```

### 1033. Moving Stones Until Consecutive

Three stones are on a number line at positions `a`, `b`, and `c`.

Each turn, you pick up a stone at an endpoint (ie., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints.  Formally, let's say the stones are currently at positions `x, y, z` with `x < y < z`.  You pick up the stone at either position `x` or position `z`, and move that stone to an integer position `k`, with `x < k < z` and `k != y`.

The game ends when you cannot make any more moves, ie. the stones are in consecutive positions. When the game ends, what is the minimum and maximum number of moves that you could have made?  Return the answer as an length 2 array: `answer = [minimum_moves, maximum_moves]`

Example:

```
Input: a = 3, b = 5, c = 1
Output: [1,2] (Move the stone from 1 to 4; or move the stone from 1 to 2 to 4.)
```

Solution: 很无聊的数学题

```cpp
vector<int> numMovesStones(int a, int b, int c) {
    int x = min(a, min(b, c));
    int z = max(a, max(b, c));
    int y = (b != x && b != z)? b: (a != x && a != z)? a: c;
    vector<int> res;
    int max_move = z - x - 2;
    int min_move_1 = 2, min_move_2 = 2;
    if (x + 1 == y) --min_move_1;
    if (y + 1 == z) --min_move_1;
    if (y + 2 == z || x + 2 == y) --min_move_2;
    int min_move = min(min_move_1, min_move_2);
    res.push_back(min_move);
    res.push_back(max_move);
    return res;
}
```

### 1034. Coloring A Border

Given a 2-dimensional `grid` of integers, each value in the grid represents the color of the grid square at that location. Two squares belong to the same *connected component* if and only if they have the same color and are next to each other in any of the 4 directions.

The *border* of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).

Given a square at location `(r0, c0)` in the grid and a `color`, color the border of the connected component of that square with the given `color`, and return the final `grid`.

Example:

```
Input: grid = [
    [1,2,2],
    [2,3,2]
], r0 = 0, c0 = 1, color = 3
Output: [
    [1,3,3],
    [2,3,3]
]
```

Solution: dfs或bfs

```cpp
// method 1: bfs
vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {
    vector<pair<int, int>> retv;
    queue<pair<int, int>> q;
    q.push(pair<int, int>(r0, c0));
    vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));
    vector<vector<int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};
    visited[r0][c0] = true;
    while (!q.empty()) {
        auto e = q.front();q.pop();
        int x = e.first, y = e.second;
        for (auto d : dirs) {
            int _x = x + d[0], _y = y + d[1];
            if (_x >= 0 && _x < grid.size() && _y >= 0 && _y < grid[0].size() && grid[_x][_y] == grid[x][y]) {
                if (!visited[_x][_y]) {
                    q.push(pair<int, int>(_x, _y));    
                    visited[_x][_y] = true;
                }
            } else {
                retv.push_back(pair<int, int>(x, y));
            }
        }
    }
    for (auto e: retv) {
        grid[e.first][e.second] = color;
    }
    return grid;
}
// method2: dfs
void dfs(vector<vector<int>>& g, int r, int c, int cl) {
    if (r < 0 || c < 0 || r >= g.size() || c >= g[r].size() || g[r][c] != cl) return;
    g[r][c] = -cl;
    dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl);
    if (r > 0 && r < g.size() - 1 && c > 0 && c < g[r].size() - 1 && cl == abs(g[r - 1][c]) && cl == abs(g[r + 1][c]) && cl == abs(g[r][c - 1]) && cl == abs(g[r][c + 1])) g[r][c] = cl;
}
vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {
    dfs(grid, r0, c0, grid[r0][c0]);
    for (auto i = 0; i < grid.size(); ++i)
    for (auto j = 0; j < grid[i].size(); ++j) grid[i][j] = grid[i][j] < 0? color: grid[i][j];
    return grid;
}
```

### 1035. Uncrossed Lines

We write the integers of `A` and `B` (in the order they are given) on two separate horizontal lines. Now, we may draw *connecting lines*: a straight line connecting two numbers `A[i]` and `B[j]` such that:

- `A[i] == B[j]`;
- The line we draw does not intersect any other connecting (non-horizontal) line.

Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line. Return the maximum number of connecting lines we can draw in this way.

Example:

```
Input: A = [1,4,2], B = [1,2,4]
Output: 2 (
    [1,4,2]
     |  \
    [1,2,4]
)
```

Solution: dp，一定要背

```cpp
int maxUncrossedLines(vector<int>& A, vector<int>& B) {
    vector<vector<int>> dp(A.size() + 1, vector<int>(B.size() + 1, 0));
    for (int i = 1; i <= A.size(); ++i) {
        for (int j = 1; j <= B.size(); ++j) {
            if (A[i-1] == B[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp.back().back();
}
```

### 1037. Valid Boomerang

A *boomerang* is a set of 3 points that are all distinct and **not** in a straight line. Given a list of three points in the plane, return whether these points are a boomerang.

Example:

```
Input: [[1,1],[2,3],[3,2]]
Output: true
```

Solution: 用斜率判断，单独判断 `dx=0` 的情况

```cpp
bool isBoomerang(vector<vector<int>>& points) {
    if (points[1] == points[2] || points[0] == points[1] || points[0] == points[2]) return false;
    double dxa = points[1][0] - points[0][0], dxb = points[2][0] - points[1][0];
    double dya = points[1][1] - points[0][1], dyb = points[2][1] - points[1][1];
    if (dxa == 0 || dxb == 0) {
        if (dxa == 0 && dxb == 0) return false;
        return true;
    }
    return dya / dxa != dyb / dxb;
}
```

### 1038. Binary Search Tree to Greater Sum Tree

Given the root of a binary **search** tree with distinct values, modify it so that every `node` has a new value equal to the sum of the values of the original tree that are greater than or equal to `node.val`.

Example:

```
Input: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
        4
     /     \
    1       6
  /   \   /   \
 0     2 5     7
        \       \
         3       8
Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
        30
     /     \
    36     21
  /   \   /   \
36    35 26   15
        \       \
        33       8
```

Solution: 左右倒置的中序遍历

```cpp
TreeNode* bstToGst(TreeNode* root) {
    if (!root) return root;
    int sum = 0;
    helper(root, sum);
    return root;
}

void helper(TreeNode* root, int & sum) {
    if (!root) return;
    helper(root->right, sum);
    sum += root->val;
    root->val = sum;
    helper(root->left, sum);
}
```

### 1039. Minimum Score Triangulation of Polygon

Given `N`, consider a convex `N`-sided polygon with vertices labelled `A[0], A[i], ..., A[N-1]` in clockwise order.

Suppose you triangulate the polygon into `N-2` triangles.  For each triangle, the value of that triangle is the **product** of the labels of the vertices, and the *total score* of the triangulation is the sum of these values over all `N-2` triangles in the triangulation.

Return the smallest possible total score that you can achieve with some triangulation of the polygon.

Example:

```
Input: [3,7,4,5]
Output: 144 (There are two triangulations with possible scores 3*7*5 + 4*5*7 = 245 and 3*4*5 + 3*4*7 = 144)
```

Solution: dp，注意这种分割的题都可以从中间分开，左右取dp/前缀和的值（类似1031），十分巧妙，一定要背

```cpp
int minScoreTriangulation(vector<int>& A) {
    int N = A.size();
    if (N == 3) return accumulate(A.begin(), A.end(), 1, multiplies<int>());
    vector<vector<int>> dp(N, vector<int>(N, INT_MAX));
    for (int l = 3; l <= N; ++l) {
        for (int s = 0; s <= N - l; ++s) {
            int e = s + l - 1;
            for (int p = s + 1; p < e; ++p) {
                // Divide [s..e] into three polygon - [s..p][p..e][s,p,e]
                int lhs = (p - s == 1)? 0 :dp[s][p];
                int rhs = (e - p == 1)? 0 :dp[p][e];
                dp[s][e] = min(dp[s][e], lhs + rhs + A[s] * A[p] * A[e]);
            }
        }
    }
    return dp[0][N - 1];
}
```

### 1041. Robot Bounded In Circle

On an infinite plane, a robot initially stands at `(0, 0)` and faces north.  The robot can receive one of three instructions:

- `"G"`: go straight 1 unit;
- `"L"`: turn 90 degrees to the left;
- `"R"`: turn 90 degress to the right.

The robot performs the `instructions` given in order, and repeats them forever. Return `true` if and only if there exists a circle in the plane such that the robot never leaves the circle.

Example:

```
Input: "GGLLGG"
Output: true
```

Solution: 只要变了方向或者最后回到了原点，即会形成回路

```cpp
bool isRobotBounded(string instructions) {
    vector<vector<int>> go = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int i = 0, x = 0, y = 0;
    for (char c: instructions) {
        if (c == 'R') i = (i+1) % 4;
        else if (c == 'L') i = (i+3) % 4;
        else {
            x += go[i][0];
            y += go[i][1];
        }
    }
    return (x == 0 && y == 0) || i > 0;
}
```

### 1042. Flower Planting With No Adjacent

You have `N` gardens, labelled `1` to `N`.  In each garden, you want to plant one of 4 types of flowers. `paths[i] = [x, y]` describes the existence of a bidirectional path from garden `x` to garden `y`. Also, there is no garden that has more than 3 paths coming into or leaving it.

Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers. Return **any** such a choice as an array `answer`, where `answer[i]`is the type of flower planted in the `(i+1)`-th garden.  The flower types are denoted 1, 2, 3, or 4.  It is guaranteed an answer exists.

Example:

```
Input: N = 3, paths = [[1,2],[2,3],[3,1]]
Output: [1,2,3]
```

Solution: dfs，注意本题因为一定有解且每个花园最多连三个其他花园，所以没有必要用染色法（dfs+queue）

```cpp
vector<int> gardenNoAdj(int n, vector<vector<int>>& paths) {
    unordered_map<int, unordered_set<int>> g;
    vector<int> ans(n, 0);
    for (auto& path : paths) {
        g[path[0]].insert(path[1]);
        g[path[1]].insert(path[0]);
    }
    for (int i = 1; i <= n; ++i) {
        set<int> s{1, 2, 3, 4};
        for (auto& n : g[i]) s.erase(ans[n - 1]);
        ans[i - 1] = *s.begin();
    }
    return ans;
}
```

### 1043. Partition Array for Maximum Sum

Given an integer array `A`, you partition the array into (contiguous) subarrays of length at most `K`.  After partitioning, each subarray has their values changed to become the maximum value of that subarray. Return the largest sum of the given array after partitioning.

Example:

```
Input: A = [1,15,7,9,2,5,10], K = 3
Output: 84 ([15,15,15,9,10,10,10])
```

Solution: dp

```cpp
int maxSumAfterPartitioning(vector<int>& A, int K) {
    int n = A.size();
    vector<int> dp(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        int cur_max = INT_MIN;
        for (int j = i; j >= max(i - K + 1, 1); --j) {
            cur_max = max(cur_max, A[j - 1]);
            dp[i] = max(dp[i], cur_max * (i - j + 1) + dp[j-1]);
        }
    }
    return dp.back();
}
```

### 1046. Last Stone Weight

We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose the two **heaviest** rocks and smash them together.  Suppose the stones have weights `x` and `y` with `x <= y`.  The result of this smash is:

- If `x == y`, both stones are totally destroyed;
- If `x != y`, the stone of weight `x` is totally destroyed, and the stone of weight `y` has new weight `y-x`.

At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)

Example:

```
Input: [2,7,4,1,8,1]
Output: 1
```

Solution: priority queue

```cpp
int lastStoneWeight(vector<int>& stones) {
    priority_queue<int> pq(stones.begin(), stones.end());
    while (pq.size() > 1) {
        int y = pq.top();
        pq.pop();
        int x = pq.top();
        pq.pop();
        if(x != y) pq.push(y-x);
    }
    return pq.empty() ? 0 : pq.top();
}
```

### 1047. Remove All Adjacent Duplicates In String

Given a string `S` of lowercase letters, a *duplicate removal* consists of choosing two adjacent and equal letters, and removing them. We repeatedly make duplicate removals on S until we no longer can. Return the final string after all such duplicate removals have been made.  It is guaranteed the answer is unique.

Example:

```
Input: "abbaca"
Output: "ca"
```

Solution: stack

```cpp
string removeDuplicates(string S) {
    vector<char> v;
    for (auto c: S) {
        if (v.empty()) v.push_back(c);
        else if (v.back() == c) v.pop_back();
        else v.push_back(c);
    }
    string ret;
    for (auto c: v) ret += c;
    return ret;
}
```

### 1048. Longest String Chain

Given a list of words, each word consists of English lowercase letters. Let's say `word1` is a predecessor of `word2` if and only if we can add exactly one letter anywhere in `word1` to make it equal to `word2`.  For example, `"abc"` is a predecessor of `"abac"`.

A *word chain* is a sequence of words `[word_1, word_2, ..., word_k]` with `k >= 1`, where `word_1` is a predecessor of `word_2`, `word_2` is a predecessor of `word_3`, and so on. Return the longest possible length of a word chain with words chosen from the given list of `words`.

Example:

```
Input: ["a","b","ba","bca","bda","bdca"]
Output: 4 (["a","ba","bda","bdca"])
```

Solution: dp，需要先sort一下

```cpp
int longestStrChain(vector<string>& words) {
    int n = words.size(), global_max = 1;
    sort(words.begin(), words.end(), [](const string & a, const string & b) {return a.length() < b.length();});
    vector<int> dp(n, 1);
    for (int i = 0; i < n; ++i) {
        string cur = words[i];
        for (int j = 0; j < i; ++j) {
            if (addOne(cur, words[j])) {
                dp[i] = max(dp[i], 1 + dp[j]);
            }
        }
        global_max = max(global_max, dp[i]);
    }
    return global_max;
}

bool addOne(const string & a, const string & b) {
    if (a.length() - b.length() != 1) return false;
    int pos = 0;
    for (const char & c: a) {
        if (c == b[pos]) ++pos;
    }
    return pos == b.length();
}
```