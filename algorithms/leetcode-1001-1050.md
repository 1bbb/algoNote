# LeetCode 1001 - 1050

### 1003. Check If Word Is Valid After Substitutions

We are given that the string `"abc"` is valid. From any valid string `V`, we may split `V` into two pieces `X` and `Y` such that `X + Y` (`X` concatenated with `Y`) is equal to `V`.  (`X`or `Y` may be empty.)  Then, `X + "abc" + Y` is also valid.

If for example `S = "abc"`, then examples of valid strings are: `"abc", "aabcbc", "abcabc", "abcabcababcc"`.  Examples of **invalid** strings are: `"abccba"`, `"ab"`, `"cababc"`, `"bac"`. Return `true` if and only if the given string `S` is valid.

Example:

```
Input: "abcabcababcc"
Output: true
```

Solution: stack（实际上需要用vector，方便获得back()-1位置的值）

```cpp
bool isValid(string S) {
    vector<char> stack;
    for (char c : S) {
        if (c == 'c') {
            int n = stack.size();
            if (n < 2 || stack[n - 1] != 'b' || stack[n - 2] != 'a') return false;
            stack.pop_back(), stack.pop_back();
        } else {
            stack.push_back(c);
        }
    }
    return stack.empty();
}
```

### 1004. Max Consecutive Ones III

Given an array `A` of 0s and 1s, we may change up to `K` values from 0 to 1. Return the length of the longest (contiguous) subarray that contains only 1s. 

Example:

```
Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
Output: 6 ([1,1,1,0,0,1,1,1,1,1,1])
```

Solution: 滑动窗口

```cpp
int longestOnes(vector<int>& A, int K) {
    int l = 0, r = 0, flips = 0, res = 0;
    while (r < A.size()) {
        if (A[r] == 0) {
            if (flips < K) {
                ++flips;
            } else {
                if (A[l] == 1)
                    while (A[l++] == 1) continue;
                else ++l;
            }
        }
        res = max(res, ++r - l);
    }
    return res;
}
```

### 1005. Maximize Sum Of Array After K Negations

Given an array `A` of integers, we **must** modify the array in the following way: we choose an `i` and replace `A[i]` with `-A[i]`, and we repeat this process `K` times in total.  (We may choose the same index `i` multiple times.) Return the largest possible sum of the array after modifying it in this way.

Example:

```
Input: A = [3,-1,0,2], K = 3
Output: 6
```

Solution: 分正负数操作即可

```cpp
int largestSumAfterKNegations(vector<int>& A, int K) {
    int n = A.size();
    vector<int> pos, neg;
    for (auto & i: A) {
        if (i < 0) neg.push_back(i);
        else pos.push_back(i);
    }
    int sum = accumulate(pos.begin(), pos.end(), 0);
    if (K <= neg.size()) {
        sort(neg.begin(), neg.end());
        sum -= accumulate(neg.begin(), neg.begin() + K, 0);
        sum += accumulate(neg.begin() + K, neg.end(), 0);
    } else {
        for (auto & i: neg) {
            pos.push_back(-i);
        }
        sort(pos.begin(), pos.end());
        if ((K - neg.size()) % 2) {
            sum -= 2 * pos[0];
        }
    }
    return sum;
}
```

### 1006. Clumsy Factorial

Normally, the factorial of a positive integer `n` is the product of all positive integers less than or equal to `n`.  For example, `factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1`.

We instead make a *clumsy factorial:* using the integers in decreasing order, we swap out the multiply operations for a fixed rotation of operations: multiply (*), divide (/), add (+) and subtract (-) in this order.

For example, `clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1`.  However, these operations are still applied using the usual order of operations of arithmetic: we do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.

Additionally, the division that we use is *floor division* such that `10 * 9 / 8` equals `11`.  This guarantees the result is an integer.

`Implement the clumsy` function as defined above: given an integer `N`, it returns the clumsy factorial of `N`

Example:

```
Input: 10
Output: 12 (12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1)
```

Solution: 数学题

```cpp
int clumsy(int N) {
    if (N <= 2) return N;
    if (N <= 4) return N + 3;
    if ((N - 4) % 4 == 0) return N + 1;
    else if ((N - 4) % 4 <= 2) return N + 2;
    return N - 1;
}
```

### 1007. Minimum Domino Rotations For Equal Row

In a row of dominoes, `A[i]` and `B[i]` represent the top and bottom halves of the `i`-th domino.  (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.) We may rotate the `i`-th domino, so that `A[i]` and `B[i]` swap values.

Return the minimum number of rotations so that all the values in `A` are the same, or all the values in `B` are the same. If it cannot be done, return `-1`.

Example:

```
Input: A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]
Output: 2 (If we rotate the second and fourth dominoes, we can make every value in A equal to 2.)
```

Solution: 遍历一遍找满足条件的数字，再遍历一遍求最小交换次数，注意各种细节，一定要背

```cpp
int minDominoRotations(vector<int>& A, vector<int>& B) {
    // find mode
    int mode_a = A[0], mode_b = B[0];
    int n = A.size();
    for (int i = 1; i < n; ++i) {
        if (mode_a && mode_a != A[i] && mode_a != B[i]) mode_a = 0;
        if (mode_b && mode_b != A[i] && mode_b != B[i]) mode_b = 0;
    }
    if (!mode_a && !mode_b) return -1;

    // find move times
    int move_cnt = INT_MAX, mode = mode_a? mode_a: mode_b;
    int move_cnt_a = 0, move_cnt_b = 0;
    for (int i = 0; i < n; ++i) {
        if (mode != A[i]) ++move_cnt_a;
        if (mode != B[i]) ++move_cnt_b;
    }
    move_cnt = min(move_cnt, min(move_cnt_a, n-move_cnt_a));
    move_cnt = min(move_cnt, min(move_cnt_b, n-move_cnt_b));

    return move_cnt;
}
```

### 1008. Construct Binary Search Tree from Preorder Traversal

Return the root node of a binary **search** tree that matches the given `preorder` traversal.

Example:

```
Input: [8,5,1,7,10,12]
Output: [8,5,10,1,7,null,12]
    8
   / \
  5   10
 / \    \
1   7   12
```

Solution: 二分法，一定要背

```cpp
TreeNode* bstFromPreorder(vector<int>& preorder) {
    return helper(preorder, 0, preorder.size());
}

TreeNode* helper(vector<int>& preorder, int l, int r) {
    if (l == r) return NULL;
    TreeNode* root = new TreeNode(preorder[l]);
    if (l + 1 < r) {
        int pos = binary_search(preorder, l + 1, r, preorder[l]);
        root->left  = helper(preorder, l+1, pos);
        root->right = helper(preorder, pos, r);
    }
    return root;
}

int binary_search(vector<int>& preorder, int l, int r, int target) {
    while (l < r) {
        int m = (l + r) / 2;
        if (preorder[m] < target) l = m + 1;
        else r = m;
    }
    return l;
}
```

### 1009. Complement of Base 10 Integer

Every non-negative integer `N` has a binary representation.  For example, `5` can be represented as `"101"` in binary, `11` as `"1011"` in binary, and so on.  Note that except for `N = 0`, there are no leading zeroes in any binary representation. The *complement* of a binary representation is the number in binary you get when changing every `1` to a `0` and `0` to a `1`.  For example, the complement of `"101"` in binary is `"010"` in binary. For a given number `N` in base-10, return the complement of it's binary representation as a base-10 integer.

Example:

```
Input: 5
Output: 2 (5 is "101" in binary, with complement "010" in binary, which is 2 in base-10.)
```

Solution: 2^n - 1 - input

```cpp
int bitwiseComplement(int N) {
    int X = 1;
    while (N > X) X = X * 2 + 1;
    return X - N;
}
```

### 1010. Pairs of Songs With Total Durations Divisible by 60

In a list of songs, the `i`-th song has a duration of `time[i]`seconds. Return the number of pairs of songs for which their total duration in seconds is divisible by `60`.  Formally, we want the number of indices `i < j` with `(time[i] + time[j]) % 60 == 0`.

Example:

```
Input: [30, 20, 150, 100, 40]
Output: 3 ([0, 2], [1, 3], [1, 4])
```

Solution: 前缀和，和974相同，注意既可以先统计然后算`C(freq,  2)`，也可以在遍历时求和，即`1 + 2 + ... + freq = freq * (freq-1) / 2 = C(freq, 2)`

```cpp
int numPairsDivisibleBy60(vector<int>& time) {
    vector<int> freqmap(60, 0);
    int res = 0;
    for (const int & t: time) {
        int modt = t % 60;
        if (modt == 0) res += freqmap[0];
        else res += freqmap[60 - modt];
        ++freqmap[modt];
    }
    return res;
}
```

### 1011. Capacity To Ship Packages Within D Days

A conveyor belt has packages that must be shipped from one port to another within `D` days. The `i`-th package on the conveyor belt has a weight of `weights[i]`.  Each day, we load the ship with packages on the conveyor belt (in the order given by `weights`). We may not load more weight than the maximum weight capacity of the ship. Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within `D` days.

Example:

```
Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5
Output: 15 ([1, 2, 3, 4, 5], [6, 7], [8], [9], [10])
```

Solution: 二分法，`l = max(max_element(weights), sum(weights) / D) , r = sum(weights)`，一定要背

```cpp
int countDays(vector<int>& ws, int tot_cap, int cur_cap = 0, int res = 1) {
    for (int w : ws) {
        cur_cap += w;
        if (cur_cap > tot_cap) ++res, cur_cap = w;
    }
    return res;
}
int shipWithinDays(vector<int>& ws, int D) {
    int r = accumulate(begin(ws), end(ws), 0);
    int l = max(r / D, *max_element(begin(ws), end(ws)));
    while (l < r) {
        int m = (l + r) / 2;
        if (countDays(ws, m) <= D) r = m;
        else l = m + 1;
    }
    return l;
}
```

### 1013. Partition Array Into Three Parts With Equal Sum

Given an array `A` of integers, return `true` if and only if we can partition the array into three **non-empty** parts with equal sums.

Example:

```
Input: [0,2,1,-6,6,-7,9,1,2,0,1]
Output: true ([0,2,1],[-6,6,-7,9,1],[2,0,1])
```

Solution: 遍历一遍找是否有`sum / 3`和`sum * 2 /3`的位置

```cpp
bool canThreePartsEqualSum(vector<int>& A) {
    int total = accumulate(A.begin(), A.end(), 0);
    if (total % 3) return false;
    bool f1 = false;
    int csum = 0;
    for (int num: A) {
        csum += num;
        if (!f1 && csum == total/3) f1 = true;
        else if (f1 && csum == (2*total)/3) return true;
    }
    return false;
}
```

### 1014. Best Sightseeing Pair

Given an array `A` of positive integers, `A[i]` represents the value of the `i`-th sightseeing spot, and two sightseeing spots `i` and `j` have distance `j - i` between them. The *score* of a pair (`i < j`) of sightseeing spots is (`A[i] + A[j] + i - j)` : the sum of the values of the sightseeing spots, **minus** the distance between them. Return the maximum score of a pair of sightseeing spots.

Example:

```
Input: [8,1,5,2,6]
Output: 11 (i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11)
```

Solution: 先做前缀和，然后从后往前遍历找每个位置之后的最大值，然后再遍历一遍即可

```cpp
int maxScoreSightseeingPair(vector<int>& A) {
    int n = A.size();
    if (n == 2) return A[0] + A[1] - 1;
    vector<int> curmax(n, 0);
    // build curmax from i to n
    for (int i = 1; i < n; ++i) {
        curmax[i] = A[i] - i;
    }
    for (int i = n - 2 ; i >= 1; --i) {
        curmax[i] = max(curmax[i+1], curmax[i]);
    }
    // scan through
    int res = A[0] + curmax[1], cur = res;
    for (int i = 1; i < n - 1; ++i) {
        cur = A[i] + i + curmax[i+1];
        res = max(res, cur);
    }
    return res;
}
```

### 1017. Convert to Base -2

Given a number `N`, return a string consisting of `"0"`s and `"1"`s that represents its value in base `**-2**` (negative two). The returned string must have no leading zeroes, unless the string is `"0"`.

Example:

```
Input: 2
Output: "110" ((-2) ^ 2 + (-2) ^ 1 = 2)
```

Solution: 循环mod -2，取绝对值，一定要背

```cpp
string baseNeg2(int N) {
    string s = "";
    while (N) {
        int a = abs(N % (-2));
        s = (a == 0? '0' :'1') + s;
        N = (N - a) / (-2);
    }
    return s == ""? "0" : s;   
}
```

### 1018. Binary Prefix Divisible By 5

Given an array `A` of `0`s and `1`s, consider `N_i`: the i-th subarray from `A[0]` to `A[i]` interpreted as a binary number (from most-significant-bit to least-significant-bit.) Return a list of booleans `answer`, where `answer[i]` is `true` if and only if `N_i` is divisible by 5.

Example:

```
Input: [0,1,1,1,1,1]
Output: [true,false,false,false,true,false]
```

Solution: 遍历一遍即可，注意一个细节是在每次计算完当前位置时mod 5，防止超出最大范围，一定要背

```cpp
vector<bool> prefixesDivBy5(vector<int>& A) {
    vector<bool> result;
    int number = 0;
    for (int i = 0; i < A.size(); i++){
        number <<= 1;
        number += A[i];
        number %= 5;  // attention!
        result.push_back(number % 5 == 0);
    }
    return result;
}
```

### 1019. Next Greater Node In Linked List

We are given a linked list with `head` as the first node. Return an array of integers `answer`, where `answer[i] = next_larger(node_{i+1})`.

Example:

```
Input: 2->7->4->3->5
Output: [7,0,5,5,0]
```

Solution: stack

```cpp
vector<int> nextLargerNodes(ListNode* head) {
    vector<int> ans;
    if (!head) return ans;
    stack<pair<int, int>> s;  // {node_val, node_index} 
    int i = 0;
    while (head) {
        while (!s.empty() && head->val > s.top().first) {
            ans[s.top().second] = head->val;
            s.pop();
        }
        s.push({head->val, i++});
        ans.push_back(0);
        head = head->next;
    }
    return ans;
}
```

### 1020. Number of Enclaves

Given a 2D array `A`, each cell is 0 (representing sea) or 1 (representing land). A move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid. Return the number of land squares in the grid for which we **cannot** walk off the boundary of the grid in any number of moves.

Example:

```
Input: [
    [0,0,0,0],
    [1,0,1,0],
    [0,1,1,0],
    [0,0,0,0]
]
Output: 3
```

Solution: dfs

```cpp
int numEnclaves(vector<vector<int>>& A) {
    int m = A.size(), n = A[0].size();
    for (int i = 0; i < m; ++i) {
        dfs(A, i, 0, m, n);
        dfs(A, i, n-1, m, n);
    }
    for (int j = 0; j < n; ++j) {
        dfs(A, 0, j, m, n);
        dfs(A, m-1, j, m, n);
    }
    int res = 0;
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (A[i][j] == 1) {
                ++res;
            }
        }
    }
    return res;
}

void dfs(vector<vector<int>>& A, int i, int j, int m, int n) {
    if (i < 0 || i >= m || j < 0 || j >= n || A[i][j] == 0) return;
    A[i][j] = 0;
    dfs(A, i-1, j, m, n);
    dfs(A, i+1, j, m, n);
    dfs(A, i, j-1, m, n);
    dfs(A, i, j+1, m, n);
}
```

### 1021. Remove Outermost Parentheses

A valid parentheses string is either empty `("")`, `"(" + A + ")"`, or `A + B`, where `A` and `B` are valid parentheses strings, and `+` represents string concatenation.  For example, `""`, `"()"`, `"(())()"`, and `"(()(()))"` are all valid parentheses strings.

A valid parentheses string `S` is **primitive** if it is nonempty, and there does not exist a way to split it into `S = A+B`, with `A` and `B`nonempty valid parentheses strings.

Given a valid parentheses string `S`, consider its primitive decomposition: `S = P_1 + P_2 + ... + P_k`, where `P_i` are primitive valid parentheses strings. Return `S` after removing the outermost parentheses of every primitive string in the primitive decomposition of `S`.

Example:

```
Input: "(()())(())(()(()))"
Output: "()()()()(())" ("()()" + "()" + "()(())")
```

Solution: 遍历一遍即可

```cpp
string removeOuterParentheses(string S) {
    string ret = "";
    int left = 0;
    for (char c: S) {
        if (c == '(') {
            if (left != 0) ret += c;
            ++left;
        } else {
            --left;
            if (left != 0) ret += c;
        }
    }
    return ret;
}
```

### 1022. Sum of Root To Leaf Binary Numbers

Given a binary tree, each node has value `0` or `1`.  Each root-to-leaf path represents a binary number starting with the most significant bit. For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers.

Example:

```
Input: [1,0,1,0,1,0,1]
     1
   /   \
  0     1
 / \   / \
0   1 0   1
Output: 22 ((100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22)
```

Solution: dfs

```cpp
int sum;
void findSum(TreeNode* root, int val) {
    if (!root) return;
    val <<= 1;
    val += root->val;
    if (!root->left && !root->right) {
        sum += val;
        return;
    }
    findSum(root->left, val);
    findSum(root->right, val);
}
int sumRootToLeaf(TreeNode* root) {
    sum = 0;
    findSum(root, 0);
    return sum;
}
```

### 1023. Camelcase Matching

A query word matches a given `pattern` if we can insert **lowercase** letters to the pattern word so that it equals the `query`. (We may insert each character at any position, and may insert 0 characters.)

Given a list of `queries`, and a `pattern`, return an `answer` list of booleans, where `answer[i]` is true if and only if `queries[i]`matches the `pattern`.

Example:

```
Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer"], pattern = "FoBa"
Output: [true,false,true,false]
```

Solution: 找到所有的组成词，然后看剩余的字母是不是全部小写，可以用find，lambda和algorithm简化代码

```cpp
vector<bool> camelMatch(vector<string>& qs, string pattern) {
    vector<bool> res;
    for (auto i = 0; i < qs.size(); ++i) {
        for (auto p = -1, j = 0; j < pattern.size(); ++j) {
            p = qs[i].find(pattern[j], p + 1);
            if (p == string::npos) {
                res.push_back(false);
                break;
            }
            qs[i][p] = 'a';
        }
        if (res.size() <= i) {
            res.push_back(all_of(begin(qs[i]), end(qs[i]), [](char ch) { return islower(ch); }));
        }
    }
  return res;
}
```

### 1024. Video Stitching

You are given a series of video clips from a sporting event that lasted `0 <= T <= 100` seconds.  These video clips can be overlapping with each other and have varied lengths.

Each video clip `clips[i]` is an interval: it starts at time `clips[i][0]` and ends at time `clips[i][1]`.  We can cut these clips into segments freely: for example, a clip `[0, 7]` can be cut into segments `[0, 1] + [1, 3] + [3, 7]`.

Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event (`[0, T]`).  If the task is impossible, return `-1`.

Example:

```
Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
Output: 3 (We take the clips [0,2], [8,10], [1,9]; a total of 3 clips to form [0, 10])
```

Solution: 鉴于本题T范围较小，不需要sort，可以直接遍历一遍clips记录每个开始时间对应的最晚结束时间，然后按照时间T遍历一遍，一定要背

```cpp
int videoStitching(vector<vector<int>>& clips, int T) {
    vector<int> max_end(T + 1, -1);
    for (const auto& clip : clips) {
        if (clip[0] <= T) {
            max_end[clip[0]] = max(max_end[clip[0]], clip[1]);
        }
    }
    int ret = 1;
    int curr_end = max_end[0];
    int next_end = 0;
    for (int curr_start = 0; curr_start <= curr_end && curr_end < T; ++curr_start) {
        next_end = max(next_end, max_end[curr_start]);
        if (curr_start == curr_end) {
            curr_end = next_end;
            if (curr_start == curr_end) return -1;
            ++ret;
        }
    }
    return curr_end >= T ? ret : -1;
}
```

### 1025. Divisor Game

Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number `N` on the chalkboard.  On each player's turn, that player makes a *move* consisting of:

- Choosing any `x` with `0 < x < N` and `N % x == 0`.
- Replacing the number `N` on the chalkboard with `N - x`.

Also, if a player cannot make a move, they lose the game. Return `True` if and only if Alice wins the game, assuming both players play optimally.

Example:

```
Input: 2
Output: true
```

Solution: 奇偶数

```cpp
bool divisorGame(int N) {
    return N % 2 == 0;
}
```